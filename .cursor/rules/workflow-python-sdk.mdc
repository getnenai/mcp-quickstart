---
description: "Python SDK guidance for NenAI workflow.py files"
globs: ["workflows/**/*.py"]
alwaysApply: false
---

# Python SDK Guidance for NenAI Workflows

This guide provides Python-specific patterns and best practices for authoring `workflow.py` files.

## Handler Function Pattern

```python
def handler(payload: dict) -> dict:
    """
    Main workflow entry point.
    
    Args:
        payload: Input parameters passed when the workflow is executed.
                 Access variables like: payload.get("VAR_NAME", "default")
    
    Returns:
        dict: Results to return from workflow execution.
              Should include at minimum: {"success": bool}
    """
    # Implementation
```

## Payload Access Patterns

### Optional Variables with Defaults
```python
def handler(payload: dict) -> dict:
    # Optional with default value
    url = payload.get("WEBSITE_URL", "https://default.com")
    timeout = payload.get("TIMEOUT", 30)
    max_retries = payload.get("MAX_RETRIES", 3)
```

### Required Variables
```python
def handler(payload: dict) -> dict:
    # Required (raises KeyError if missing)
    patient_name = payload["PATIENT_NAME"]
    
    # Better: Validate and return error
    if "PATIENT_NAME" not in payload:
        return {"success": False, "error": "PATIENT_NAME is required"}
    
    patient_name = payload["PATIENT_NAME"]
```

### Type Checking
```python
def handler(payload: dict) -> dict:
    patient_name = payload.get("PATIENT_NAME")
    
    # Validate type
    if not isinstance(patient_name, str):
        return {"success": False, "error": "PATIENT_NAME must be a string"}
    
    # Validate not empty
    if not patient_name or not patient_name.strip():
        return {"success": False, "error": "PATIENT_NAME cannot be empty"}
```

## Return Structure Patterns

### Success Response
```python
return {
    "success": True,
    "data": extracted_data,
    "message": "Workflow completed successfully",
    "metadata": {
        "records_processed": 10,
        "execution_time": 45.2
    }
}
```

### Failure Response
```python
return {
    "success": False,
    "error": "Specific error message",
    "details": {
        "step": "authentication",
        "reason": "Invalid credentials",
        "attempted_username": username
    }
}
```

## Error Handling Patterns

### Using try/except with WorkflowError
```python
from nen.workflow import agent, WorkflowError
import logging

def handler(payload: dict) -> dict:
    try:
        agent("Click submit button")
    except WorkflowError as e:
        logging.error("Agent action failed", extra={
            "error": str(e),
            "action": "click submit"
        })
        return {"success": False, "error": f"Failed to click submit: {e}"}
```

### Graceful Degradation
```python
def handler(payload: dict) -> dict:
    # Try primary method
    if not login_with_sso(payload):
        logging.warning("SSO login failed, trying password login")
        # Fallback to alternative method
        if not login_with_password(payload):
            return {"success": False, "error": "All login methods failed"}
    
    # Continue workflow
    return {"success": True}
```

### Validation Chain
```python
def handler(payload: dict) -> dict:
    # Step 1: Validate
    agent("Open Firefox")
    if not validate("Is Firefox open?", timeout=10):
        return {"success": False, "error": "Failed to open browser"}
    
    # Step 2: Navigate
    agent(f"Navigate to {url}")
    if not validate("Is page loaded?", timeout=20):
        return {"success": False, "error": "Failed to load page"}
    
    # Step 3: Interact
    agent("Click submit")
    if not validate("Is confirmation visible?", timeout=15):
        return {"success": False, "error": "Submission failed"}
    
    return {"success": True}
```

## Logging Best Practices

### Structured Logging
```python
import logging

def handler(payload: dict) -> dict:
    # Use extra dict for structured data
    logging.info("Step 1: Authenticating", extra={
        "username": payload.get("USERNAME"),
        "step": "authentication"
    })
    
    # Log checkpoints
    logging.info("Checkpoint: Login form visible")
    
    # Log data for debugging
    result = extract("Get data", schema=schema)
    logging.info("Extraction result", extra={
        "result_type": type(result).__name__,
        "result_keys": list(result.keys()) if isinstance(result, dict) else None,
        "result": result
    })
```

### Redact Sensitive Data
```python
import logging

def handler(payload: dict) -> dict:
    username = payload.get("USERNAME")
    password = payload.get("PASSWORD")
    
    # Good: Log username but redact password
    logging.info("Authenticating", extra={
        "username": username,
        "password": "***REDACTED***"
    })
    
    # Bad: Never log passwords in plain text
    # logging.info(f"Password: {password}")  # ❌ NEVER DO THIS
```

### Log Levels
```python
import logging

def handler(payload: dict) -> dict:
    # INFO: Normal workflow progress
    logging.info("Starting workflow", extra={"step": "initialization"})
    
    # WARNING: Recoverable issues
    logging.warning("Retrying operation", extra={"attempt": 2, "max_attempts": 3})
    
    # ERROR: Failures that stop workflow
    logging.error("Failed to authenticate", extra={"error": error_message})
    
    # DEBUG: Detailed debugging info (rarely needed)
    logging.debug("Internal state", extra={"state": internal_state})
```

## Function Organization Patterns

### Helper Functions
```python
from nen.workflow import agent, validate, keyboard

def handler(payload: dict) -> dict:
    """Main entry point."""
    if not login(payload):
        return {"success": False, "error": "Login failed"}
    
    data = extract_patient_data(payload["PATIENT_NAME"])
    return {"success": True, "data": data}


def login(payload: dict) -> bool:
    """Authenticate to the system. Returns True on success."""
    agent("Navigate to login page")
    if not validate("Is login form visible?"):
        return False
    
    agent(f"Enter username '{payload.get('USERNAME')}'")
    agent("Enter password")
    keyboard.type(payload.get("PASSWORD"), interval=0.01)
    agent("Click login button")
    
    return validate("Is dashboard visible?", timeout=15)


def extract_patient_data(patient_name: str) -> dict:
    """Extract patient data from current view."""
    schema = {
        "type": "object",
        "properties": {
            "name": {"type": "string"},
            "mrn": {"type": "string"}
        }
    }
    return extract(f"Get data for patient {patient_name}", schema=schema)
```

### Multi-Phase Workflows
```python
def handler(payload: dict) -> dict:
    """Structured multi-phase workflow."""
    # Phase 1: Validation
    if not validate_inputs(payload):
        return {"success": False, "error": "Invalid inputs"}
    
    # Phase 2: Authentication
    if not authenticate(payload):
        return {"success": False, "error": "Authentication failed"}
    
    # Phase 3: Main logic
    result = execute_main_workflow(payload)
    if not result["success"]:
        return result
    
    # Phase 4: Return results
    return {"success": True, "data": result["data"]}


def validate_inputs(payload: dict) -> bool:
    """Validate required payload fields."""
    required_fields = ["USERNAME", "PASSWORD", "PATIENT_NAME"]
    return all(field in payload for field in required_fields)


def authenticate(payload: dict) -> bool:
    """Handle authentication."""
    # Implementation
    pass


def execute_main_workflow(payload: dict) -> dict:
    """Execute main workflow logic."""
    # Implementation
    pass
```

## Variable Naming Conventions

### Good Names
```python
# Descriptive and specific
patient_name = payload.get("PATIENT_NAME")
appointment_date = payload.get("APPOINTMENT_DATE")
max_retry_attempts = payload.get("MAX_RETRIES", 3)

# Boolean flags - use is/has/should prefix
is_verbose = payload.get("VERBOSE", False)
has_attachments = payload.get("INCLUDE_ATTACHMENTS", True)
should_verify = payload.get("VERIFY_DATA", True)

# Collections - use plural names
patient_names = extract("Get all patient names", schema=schema)
error_messages = []
downloaded_files = []
```

### Avoid
```python
# Too short or cryptic
pn = payload.get("PATIENT_NAME")  # ❌
d = payload.get("DATE")  # ❌
x = extract("data", schema=schema)  # ❌

# Unclear or misleading
data = payload.get("PATIENT_NAME")  # ❌ (data is too generic)
temp = validate("Is loaded?")  # ❌ (temp suggests temporary, not boolean)
```

## Common Pitfalls to Avoid

### Don't Repeat agent() Descriptions
```python
# Bad: Repetitive and vague
agent("Click button")
agent("Click button")
agent("Click button")

# Good: Specific and distinct
agent("Click the blue 'Submit' button in the bottom right")
agent("Click 'Yes' on the confirmation dialog")
agent("Click the 'Download Report' link in the table")
```

### Don't Skip Validation
```python
# Bad: No validation after critical actions
agent("Click login")
agent("Navigate to patients")  # Might fail if login failed!

# Good: Validate after each critical step
agent("Click login")
if not validate("Is dashboard visible?", timeout=15):
    return {"success": False, "error": "Login failed"}

agent("Navigate to patients")
if not validate("Is patients table visible?", timeout=10):
    return {"success": False, "error": "Navigation failed"}
```

### Don't Ignore Return Values
```python
# Bad: Ignoring validation results
validate("Is data visible?")
data = extract("Get data", schema=schema)  # Might extract wrong data!

# Good: Check validation before proceeding
if not validate("Is data visible?"):
    return {"success": False, "error": "Data not found"}

data = extract("Get data", schema=schema)
```

## For More Details

- **@workflow-guide-comprehensive** - Architecture, execution environment, advanced patterns
- **@workflow-reference-detailed** - Complete SDK reference with all function signatures
